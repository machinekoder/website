<!--
{
  "title": "Machinetalk explained - Part 1: Introduction",
  "date": "2016-11-07T22:21:50",
  "slug": "machinetalk-explained-part-1-introduction",
  "original_url": "https://machinekoder.com/machinetalk-explained-part-1-introduction/",
  "featured_image": "/static/blog_images/machinetalk-explained-part-1-introduction/machinetalk_use_case2.png"
}
-->
<span class="rt-reading-time" style="display: block;"><span class="rt-label rt-prefix"></span> <span class="rt-time">7</span> <span class="rt-label rt-postfix">minutes read<br/></span></span><p>This blog article is about Machinetalk, the middleware for distributed systems which serves as remote API to Machinekit.</p>
<p>This blog post is the first part of the Machinetalk explained series which describe different parts of the Machinetalk middleware.</p>
<p>I'm writing this blog post series since I dedicated a lot of time in the last years working on the Machinetalk technology stack.</p>
<p>My target is to explain the considerations behind Machinetalk. You may find this post useful if you are working with Machinekit or on a similar middleware solution.</p>
<p><strong>Other posts of this series:</strong></p>
<ul>
<li><strong><a href="https://machinekoder.com/machinetalk-explained-part-2-middleware-requirements/">Part 2: Middleware Requirements</a></strong></li>
<li><strong><a href="https://machinekoder.com/machinetalk-explained-part-3-technologies/">Part 3: Technologies</a></strong></li>
<li><strong><a href="https://machinekoder.com/machinetalk-explained-part-4-hal-remote/">Part 4: HAL Remote</a></strong></li>
<li><strong><a href="https://machinekoder.com/machinetalk-explained-part-5-code-generation/">Part 5: Code Generation</a></strong></li>
</ul>
<h2>Overview</h2>
<p>Machinetalk is a middleware for distributed systems introduced to the Machinekit project as a replacement for the outdated <a href="https://www.nist.gov/node/704021">Neutral Messaging Language (NML)</a>.</p>
<p>One of the reasons for adding the Machinetalk middleware into the Machinekit project is the missing network transparency of NML, which has been lost over time.</p>
<p>Currently, the transition from NML to Machinetalk is still in progress. However, wrappers around the legacy modules enable the development of remote user interfaces. The long term plan is to completely replaceNML and the wrapper components.</p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_pillars2.png"><img alt="machinetalk_pillars2" class="alignnone size-full wp-image-184" decoding="async" height="1474" loading="lazy" sizes="(max-width: 3347px) 100vw, 3347px" src="/static/blog_images/machinetalk-explained-part-1-introduction/machinetalk_pillars2.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_pillars2.png 3347w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_pillars2-300x132.png 300w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_pillars2-768x338.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_pillars2-1024x451.png 1024w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_pillars2-360x159.png 360w" width="3347"/></a></p>
<p>An essential requirement of Machinetalk is to reuse widely used message transport, serialization and service discovery standards to minimize maintenance cost and most importantly to decrease the risk of obsolescence.</p>
<p>Therefore, three core technologies serve as a basis for the middleware stack. <a href="http://zeromq.org">ZeroMQ</a> serves as messaging library, <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers (Protobuf)</a> enables platform-independent data serialization and the <a href="https://de.wikipedia.org/wiki/Zeroconf">Zero Configuration Networking (Zeroconf)</a> standard <a href="https://tools.ietf.org/html/rfc6763">DNS Service Discovery (DNS-SD)</a> over <a href="https://tools.ietf.org/html/rfc6762">Multicast DNS (mDNS)</a> works as service discovery method.</p>
<h2>Middleware</h2>
<p>The term middleware has historically been used to describe a wide variety of software. Middleware, in general, defines software that provides an abstraction layer to underlying platform dependent technologies.</p>
<p>Summarized, middleware is software that decreases the development effort of constructing distributed systems.</p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/middleware.png"><img alt="middleware" class="aligncenter size-medium wp-image-188" decoding="async" height="300" loading="lazy" sizes="(max-width: 282px) 100vw, 282px" src="/static/blog_images/machinetalk-explained-part-1-introduction/middleware-282x300.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/middleware-282x300.png 282w, https://machinekoder.com/wp-content/uploads/2016/11/middleware-768x818.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/middleware-962x1024.png 962w, https://machinekoder.com/wp-content/uploads/2016/11/middleware-254x270.png 254w" width="282"/></a></p>
<p>A typical middleware consists of service suppliers and service consumers. Suppliers produce information or provide services, and consumers require information or services.</p>
<p>For example, a heart-rate monitor device is a consumer of data produced by a heart-rate sensor. Nevertheless, the heart-rate monitor is a service supplier for a smartphone connected via a wireless network interface logging the values to a database.</p>
<p>This schema can be applied to all types of middleware independent if they are message-oriented, object-oriented or use shared-memory [zotpress items="XTEPI2RZ" style="IEEE"].</p>
<h2>Machinekit and NML</h2>
<p>I don't think I need to explain the basic concepts of <a href="http://machinekit.io">Machinekit</a> or <a href="http://linuxcnc.org">LinuxCNC</a> here since you already found this blog post. If you are not familiar with Machinekit, please check out my other blog posts or the <a href="http://machinekit.io">Machinekit homepage</a>.</p>
<p>The Machinekit design encapsulates each function into a separate software component. However, over the years these clear interfaces disappeared, and functionality of the software grew together.</p>
<p>Originally, there has been a middleware called <a href="https://www.nist.gov/node/704021">Neutral Messaging Language (NML)</a> to exchange messages between components. Parts of this middleware still exist in the Machinekit project.</p>
<p>One goal of using Machinetalk as middleware for the Machinekit project is to reintroduce proper interfaces between software components to disentangle Computer Numerical Control (CNC)-related parts of the software and the real-time control Hardware Abstraction Layer (HAL) core.</p>
<h3>Machinetalk Architecture</h3>
<p>To understand the considerations behind Machinetalk it is good to recall the underlying architecture of Machinekit.</p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/architecture.png"><img alt="architecture" class="aligncenter size-large wp-image-183" decoding="async" height="859" loading="lazy" sizes="(max-width: 640px) 100vw, 640px" src="/static/blog_images/machinetalk-explained-part-1-introduction/architecture-763x1024.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/architecture-763x1024.png 763w, https://machinekoder.com/wp-content/uploads/2016/11/architecture-224x300.png 224w, https://machinekoder.com/wp-content/uploads/2016/11/architecture-768x1031.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/architecture-201x270.png 201w" width="640"/></a></p>
<p>Hardware is abstracted and controlled by the HAL which serves as a basis for Machinekit. HAL supports real-time as well as user space components, which are composed using an HAL configuration.</p>
<p>Besides the generic HAL, the architecture of Machinekit also contains three components related to the CNC stack of the software. The CNC stack consists of the Motion Controller component which includes real-time motion control and the trajectory planner. Furthermore, the IO Controller serves as an interface for hardware that does not require real-time control capabilities such as spindle, coolant, and auxiliary controls. The Task Executor coordinates motion and IO Controller. The Task Executor contains the RS-274 GCode interpreter and sequencing logic.</p>
<p>Moreover, Graphical User Interfaces (GUIs) and Textual User Interfaces (UIs) can interact with the CNC stack as well as directly with the HAL.</p>
<h2>Usage Scenarios</h2>
<p>The Machinekit architecture is designed in a component-based fashion. However, over the time it grew more and more into a stovepipe system [zotpressInText item="{4QQ7TR6M}"] not sharing functionality between individual components.</p>
<p>A primary reason for this design problem are the shortcomings of the legacy NML middleware. The most significant limitations of NML include a static configuration, shared-memory polling for communication and a lack of language bindings for programming languages other than C, C++, and Java.</p>
<p>NML is not under active development anymore as a result of these problems. Wrappers hide NML wherever possible.</p>
<p>Over time these problems resulted in Machinekit growing into an inflexible monolithic application. However, with the support of single-board computers as target execution platform for Machinekit interesting new usage scenarios arise for Machinekit, which make a case for replacing NML with the Machinetalk middleware.</p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case2.png"><img alt="machinetalk_use_case2" class="alignnone size-full wp-image-186" decoding="async" height="2821" loading="lazy" sizes="(max-width: 4370px) 100vw, 4370px" src="/static/blog_images/machinetalk-explained-part-1-introduction/machinetalk_use_case2.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case2.png 4370w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case2-300x194.png 300w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case2-768x496.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case2-1024x661.png 1024w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case2-360x232.png 360w" width="4370"/></a></p>
<p>Usage scenario 1 shows Machinetalk as middleware for external and internal communication in Machinekit.</p>
<p>Human machine interfaces for modern machine control systems are not limited to desktop workstation computers. Instead, smart devices such as tablets or smartphones allow remote monitoring of machine status.</p>
<p>Remote Application Programming Interfaces (APIs) can also be used to ease the interaction between part designer and machine operator. For example, a designer can add new work-pieces to the production queue from a desktop computer. Furthermore, web UIs enable remote monitoring of machine status and modification of machine parameters directly from a web browser.</p>
<p>The middleware is also intended to be used internally by components of Machinekit communicating with each other. Using Machinetalk provides the means of implementing Machinekit components in high-level languages and to replace parts of the system as required by the application.</p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case1.png"><img alt="machinetalk_use_case1" class="aligncenter size-medium wp-image-185" decoding="async" height="300" loading="lazy" sizes="(max-width: 275px) 100vw, 275px" src="/static/blog_images/machinetalk-explained-part-1-introduction/machinetalk_use_case1-275x300.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case1-275x300.png 275w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case1-768x837.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case1-940x1024.png 940w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case1-248x270.png 248w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case1.png 1852w" width="275"/></a></p>
<p>Machinetalk enables the use of multiple user interfaces in a single machine control system. This setup allows running a UI instance on a stationary computer mounted next to a machine tool and a remote UI on a different device at the same time.</p>
<p>The middleware system automatically synchronizes both UI instances without requiring any further modifications by the UI designer. The secondary user interface could for example run on a hand-held device that the operator can carry around when working with the machine.</p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case3.png"><img alt="machinetalk_use_case3" class="aligncenter size-large wp-image-187" decoding="async" height="476" loading="lazy" sizes="(max-width: 640px) 100vw, 640px" src="/static/blog_images/machinetalk-explained-part-1-introduction/machinetalk_use_case3-1024x761.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case3-1024x761.png 1024w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case3-300x223.png 300w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case3-768x571.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/machinetalk_use_case3-360x267.png 360w" width="640"/></a></p>
<p>Machinetalk also allows doing the opposite. Instead of one machine configuration controlled by two separate UIs, one workstation is used to control multiple systems. This usage scenario is especially interesting in environments where either multiple machines produce the same part, or for a supervisor to monitor the production process.</p>
<h2>Scope the Machinetalk Middleware</h2>
<p>To prevent any miss-interpretations it is important to clarify the scope of the Machinetalk middleware.</p>
<p>In the diagram below you can see an overview of the communication between Machinekit and Machinetalk components.</p>
<p>Please note at this point that not all of the depicted components are already in place. Moreover, the illustrated setup is not complete and does only represent only an example to demonstrate the scope of Machinetalk.</p>
<p>Parts of the system entirely related to the Machinetalk middleware are colored<br>
blue. Components that are part of Machinekit are colored red.</br></p>
<p><a href="https://machinekoder.com/wp-content/uploads/2016/11/scope-1.png"><img alt="scope" class="alignnone size-full wp-image-190" decoding="async" height="4007" loading="lazy" sizes="(max-width: 5237px) 100vw, 5237px" src="/static/blog_images/machinetalk-explained-part-1-introduction/scope-1.png" srcset="https://machinekoder.com/wp-content/uploads/2016/11/scope-1.png 5237w, https://machinekoder.com/wp-content/uploads/2016/11/scope-1-300x230.png 300w, https://machinekoder.com/wp-content/uploads/2016/11/scope-1-768x588.png 768w, https://machinekoder.com/wp-content/uploads/2016/11/scope-1-1024x783.png 1024w, https://machinekoder.com/wp-content/uploads/2016/11/scope-1-353x270.png 353w" width="5237"/></a></p>
<p>Real-Time Host 1 in the diagram represents a typical GNU/Linux system with a real-time kernel where parts of the setup are executed in the real-time environment. This part of the setup includes the HAL and CNC specific components such as the Motion Controller and the Trajectory Planner. As can be seen in the graphic, these real-time components communicate with each other using the HAL API. Moreover, other Machinekit components are executed in user space. This includes, for example, the GCode Interpreter and Haltalk. User space applications can access HAL employing the HAL API. Furthermore, other applications such as the GCode Interpreter need to exchange messages with components executed in the real-time environment. For this purpose ring buffers (marked in the diagram with RB) are used. Important to note is that messages passed through the ring buffers are Protobuf encoded Machinetalk messages.</p>
<p>Moreover, user space components communicate with each other using Machinetalk bindings (labeled MT). Since these components are not executed in the real-time environment, full Machinetalk functionality can be used. This functionality includes ZeroMQ as transport and automatic service discovery utilizing mDNS/DNS-SD. Furthermore, distributed clients can also use Machinetalk to exchange data with the Machinetalk instance running on the Machinekit host. Some Machinetalk clients may act as bridges to other technologies. Depicted in Figure 10 is a Webtalk Bridge. This bridge translates Protobuf to JavaScript Object Notation (JSON) encoded messages and maps ZeroMQ sockets to web browser supported WebSockets (labeled WT).</p>
<p>Additionally, multiple real-time hosts can communicate with each other using fieldbus technologies. Fieldbus technologies such as Controller Area Network (CAN) or Ethernet for Control Automation Technology (EtherCAT) are real-time capable. Hence, multiple HAL instances and fieldbus enabled hardware can exchange information over fieldbuses in real-time. The Machinetalk middleware does not obligate to provide real-time capabilities. Therefore, Machinetalk does not indent to replace fieldbuses for real-time distributed controls. Instead, it enables distributed systems based on standard computer networks. However, Machinetalk can exchange information with components executed in a real-time environment passing Protobuf encoded messages over ring buffers.</p>
<h2>Coming up</h2>
<p>I hope you have enjoyed reading about Machinetalk so far.</p>
<p>The next blog article will be about the <a href="https://machinekoder.com/machinetalk-explained-part-2-middleware-requirements/">Machinetalk requirements</a> and the used technologies in more details.</p>
<p>Furthermore, I will dedicate a third blog post solely to HAL remote since it is the most important part of Machinetalk.</p>
<p>The last blog of the posts of this series will be about modeling and code generation for the Machinetalk bindins.</p>
<p>I would very much appreciate any feedback and comments.</p>
<p>Your<br/>
Machine Koder</p>
